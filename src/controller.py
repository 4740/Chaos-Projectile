"""
.. module:: controller
    :platform: Unix, Windows
    :synopsis: Generates events according input of various controllers connected to the game.
"""
#Protected keys: enter, escape
#

import pygame
import events

BLACK    = (   0,   0,   0)
WHITE    = ( 255, 255, 255)

def input_is_a_key(inpt):
    return (inpt.type == pygame.KEYDOWN or inpt.type == pygame.KEYUP)

def input_is_a_joystickbutton(inpt):
    return (inpt.type == pygame.JOYBUTTONDOWN or inpt.type == pygame.JOYBUTTONUP)
    
def input_is_a_joystickaxis(inpt):
    return inpt.type == pygame.JOYAXISMOTION

def input_is_a_joystickhat(inpt):
    return inpt.type == pygame.JOYHATMOTION

class Actions:
    MOVE_LEFT = 1
    MOVE_RIGHT = 2
    JUMP = 3
    AIM_X = 4
    AIM_MINUS_X = 5
    AIM_Y = 6
    AIM_MINUS_Y = 7

def is_aim_action(event_action):
    return (event_action == Actions.AIM_X or
            event_action == Actions.AIM_Y or
            event_action == Actions.AIM_MINUS_X or
            event_action == Actions.AIM_MINUS_Y)

def is_movement_action(event_action):
    return (event_action == Actions.JUMP or
            event_action == Actions.MOVE_LEFT or
            event_action == Actions.MOVE_RIGHT)

# This is a simple class that will help us print to the screen
class TextPrint:
    def __init__(self):
        self.reset()
        self.font = pygame.font.Font(None, 30)

    def print_(self, screen, textString):
        textBitmap = self.font.render(textString, True, BLACK)
        screen.blit(textBitmap, [self.x, self.y])
        width, height = self.font.size(textString);
        self.x += width
        return width

    def println_(self, screen, textString):
        self.print_(screen, textString)
        width, height = self.font.size(textString);
        self.x -= width
        self.line_break()
        return width

    def carriage_return(self, width):
        self.x -= width

    def line_break(self):
        self.y += self.line_height

    def reset(self):
        self.x = 10
        self.y = 10
        self.line_height = 30
        
    def indent(self):
        self.x += 10

    def unindent(self):
        self.x -= 10

class InputController:
    """InputController manages connected controllers and takes events generated by them sending other events to the game.

    :Attributes:
        - *event_manager* (events.EventManager): event manager
        - *joystick* (pygame.joystick.Joystick): game pad
    """
    def __init__(self, screen, event_manager):
        #Register InputController, so it can handle events
        self.event_manager = event_manager
        self.event_manager.register_listener(self)
        #Needed for custom control screen render
        self.screen = screen
        self.textPrint = TextPrint()
        #To store controlls
        self.actions_map = {}
        self.action_to_map = 0
        self.current_ui_point = 0
        self.use_mouse_to_aim_and_fire = False
        self.use_hat_to_aim = -1
        self.use_hat_to_move = -1
        self.controls_ready = False
        #Register game pads that are connected
        #Always needed to get a joystick work
        pygame.joystick.init()
        joystick_count = pygame.joystick.get_count()
        for i in range(joystick_count):
            joystick = pygame.joystick.Joystick(i)
            joystick.init()

    def notify(self, event):
        if isinstance(event, events.TickEvent):
            for event in pygame.event.get():
                #Common events
                if event.type == pygame.VIDEORESIZE:
                    resize_ev = events.ResizeWindowEvent(event.w, event.h)
                    self.event_manager.post(resize_ev)
                if event.type == pygame.QUIT:
                    quit_ev = events.QuitEvent()
                    self.event_manager.post(quit_ev)
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        quit_ev = events.QuitEvent()
                        self.event_manager.post(quit_ev)

                #Controls ready, input events are sent to the game
                if self.controls_ready:
                    #Pause
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_RETURN: #K_RETURN is the enter key
                            self.event_manager.post(events.TogglePauseEvent())
                    #Handle events generated by mouse
                    if self.use_mouse_to_aim_and_fire:
                        if event.type == pygame.MOUSEMOTION:
                            direction_X, direction_Y = pygame.mouse.get_pos()
                            mouse_ev = events.MouseMoved(direction_X, 
                                                         direction_Y)
                            self.event_manager.post(mouse_ev)
                        elif event.type == pygame.MOUSEBUTTONDOWN:
                            attack_request_ev = events.MouseButtonDown()
                            self.event_manager.post(attack_request_ev)
                    #Handle hats
                    if self.use_hat_to_aim > -1:
                        if event.type == pygame.JOYHATMOTION:
                            if event.hat == self.use_hat_to_aim:
                                input_event = events.SentInputAction(Actions.AIM_X, event)
                                self.event_manager.post(input_event)
                    if self.use_hat_to_move > -1:
                        if event.type == pygame.JOYHATMOTION:
                            if event.hat == self.use_hat_to_move:
                                input_event = events.SentInputAction(Actions.JUMP, event)
                                self.event_manager.post(input_event)
                    #Handle other control events
                    if (self.key_used(event)):
                        action = self.determine_action(event)
                        if action:
                                input_event = events.SentInputAction(action, event)
                                self.event_manager.post(input_event)

                #If custom keys are not initialized
                else:
                    #Toggle mouse input
                    #when the corresponding ui point is selected
                    if event.type == pygame.MOUSEBUTTONDOWN and self.current_ui_point == 0:
                        self.use_mouse_to_aim_and_fire = (not self.use_mouse_to_aim_and_fire)
                        self.inc_init_counter()
                    if event.type == pygame.JOYHATMOTION:
                        if self.current_ui_point == 1 and not event.hat == self.use_hat_to_move:
                            self.use_hat_to_aim = event.hat
                            self.inc_init_counter()
                        elif self.current_ui_point == 2 and not event.hat == self.use_hat_to_aim:
                            self.use_hat_to_move = event.hat
                            self.inc_init_counter()
                    #BACKSPACE to go one ui point back
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_BACKSPACE:
                            self.dec_input_counter()
                        elif event.key == pygame.K_RETURN:
                            #Start game with this controlls
                            if self.current_ui_point == 10: #K_RETURN is the enter key
                                self.event_manager.post(events.TogglePauseEvent())
                                self.controls_ready = True
                                if self.use_mouse_to_aim_and_fire:
                                    self.remove_aim_controls()
                                elif self.use_hat_to_aim > -1:
                                    self.remove_aim_controls()
                                    self.event_manager.post(events.ToggleContinuousAttack())
                                else:
                                    self.event_manager.post(events.ToggleContinuousAttack())
                                if self.use_hat_to_move > -1:
                                    self.remove_movement_controls()
                            #Or go one ui point further
                            else:
                                self.inc_init_counter()
                    #Draw custom controlls ui
                    self.draw()
                    if (not self.key_used(event)):
                        self.save_key(event)

    def equal_input_source(self, input1, input2):
        #Keyboard key:
        #KEYDOWN == KEYUP, same key_index --> same key toggled
        if input_is_a_key(input1) and input_is_a_key(input2):
            return (input1.key == input2.key)
        #Joystick button:
        #Similar to keyboard button, but one must check if the
        #toggled button is on the same joystick
        if input_is_a_joystickbutton(input1) and input_is_a_joystickbutton(input2):
            return (input1.button == input2.button and
                    input1.joy == input2.joy)
        #Joystick axis (or axis direction):
        #distinguish between axis which is slanted left vs right
        #(or top vs. bottom)
        #Example: when self and other_input are both slanted left,
        #have similar axis index and joystick index, then the same
        #axis was moved
        if input_is_a_joystickaxis(input1) and input_is_a_joystickaxis(input2):
            offset = 0.04 #Filter to small values
            return (((input1.value > offset and input2.value > offset) or
                    (input1.value < offset and input2.value < offset)) and
                    input1.axis == input2.axis and
                    input1.joy == input2.joy)
        #Joystickhat
        if input_is_a_joystickhat(input1) and input_is_a_joystickhat(input2):
            x_value1, y_value1 = input1.value
            x_value2, y_value2 = input2.value
            return (x_value1 == x_value2 and
                    y_value1 == y_value2 and
                    input1.hat == input2.hat and
                    input1.joy == input2.joy)
        else:
            return False

    def determine_action(self, inpt):
        for action, control in self.actions_map.iteritems():
            if self.equal_input_source(control, inpt):
                return action
        return None

    def save_key(self, event):
        """Save input to an action.
        """
        if self.action_to_map > 0 and self.action_to_map < 8:
            if (event.type == pygame.JOYBUTTONDOWN or
                event.type == pygame.JOYAXISMOTION or
                event.type == pygame.KEYDOWN):
                if event.type == pygame.KEYDOWN:
                    if not(event.key == pygame.K_BACKSPACE or
                           event.key == pygame.K_ESCAPE or
                           event.key == pygame.K_RETURN):
                        self.actions_map[self.action_to_map] = event
                        self.inc_init_counter()
                elif event.type == pygame.JOYAXISMOTION:
                    if abs(event.value) > 0.5:
                        self.actions_map[self.action_to_map] = event
                        self.inc_init_counter()
                else:
                    self.actions_map[self.action_to_map] = event
                    self.inc_init_counter()

    def key_used(self, control):
        """Is control already mapped to action.
        """
        for value in self.actions_map.itervalues():
            if self.equal_input_source(control, value):
                return True
        return False

    def inc_init_counter(self):
        """Helper for actions counter.
        """
        amount_to_skip = 0
        limit = 0
        if self.use_mouse_to_aim_and_fire or self.use_hat_to_aim > -1:
            amount_to_skip = 4
            limit = 5
        if self.use_hat_to_move > -1:
            amount_to_skip = 3
            limit = 2
        if self.use_hat_to_move > -1 and (self.use_mouse_to_aim_and_fire or self.use_hat_to_aim > -1):
            amount_to_skip = 7
            limit = 2
        if self.current_ui_point == limit:
            self.current_ui_point += amount_to_skip
        if self.current_ui_point > 10:
            self.current_ui_point = 0
        else:
            self.current_ui_point += 1
        #update action that is currently mapped
        if (self.current_ui_point-2) < 8 and (self.current_ui_point-2) > 0:
            self.action_to_map = (self.current_ui_point-2)
        else:
            self.action_to_map = 0

    def dec_input_counter(self):
        """Helper for actions counter.
        """
        amount_to_skip = 0
        limit = 0
        if self.use_mouse_to_aim_and_fire or self.use_hat_to_aim > -1:
            amount_to_skip = 4
            limit = 10
        if self.use_hat_to_move > -1:
            amount_to_skip = 3
            limit = 6
        if self.use_hat_to_move > -1 and (self.use_mouse_to_aim_and_fire or self.use_hat_to_aim > -1):
            amount_to_skip = 7
            limit = 10
        if self.current_ui_point == limit:
            self.current_ui_point -= amount_to_skip
        if self.current_ui_point > 0:
            self.current_ui_point -= 1
        else:
            self.current_ui_point = 10

        if (self.current_ui_point-2) < 8 and (self.current_ui_point-2) > 0:
            self.action_to_map = (self.current_ui_point-2)
        else:
            self.action_to_map = 0

    def remove_aim_controls(self):
        '''Remove all aim controls from action_map.
        '''
        to_remove = list()
        for action in self.actions_map.iterkeys():
            if is_aim_action(action):
                to_remove.append(action)
        for r in to_remove:
            del self.actions_map[r]

    def remove_movement_controls(self):
        '''Remove all movement controls from action_map.
        '''
        to_remove = list()
        for action in self.actions_map.iterkeys():
            if is_movement_action(action):
                to_remove.append(action)
        for r in to_remove:
            del self.actions_map[r]

    def draw(self):
        """Used for custom controlls initialisation screen
        
        :param dt: CPU tick
        :type dt: int
        """
        self.screen.fill(WHITE)
        self.textPrint.reset()
        self.textPrint.println_(self.screen, "Control settings")
        self.textPrint.line_break()
        self.textPrint.println_(self.screen, "Press 'enter' to move point further or")
        self.textPrint.println_(self.screen, "'backspace' to move back.")
        self.textPrint.println_(self.screen, "Press 'enter' on 'Use this layout?' to start.")
        self.textPrint.line_break()
        
        w = self.textPrint.print_(self.screen, "Use Mouse to fire and aim: ")
        w += self.print_key_layout(0)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Use Hat to fire and aim: ")
        w += self.print_key_layout(1)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Use Hat to move: ")
        w += self.print_key_layout(2)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        if (self.use_hat_to_move > -1):
            self.textPrint.println_(self.screen, "Move Left: -")
            self.textPrint.println_(self.screen, "Move Right: -")
            self.textPrint.println_(self.screen, "Jump: -")
        else:
            w = self.textPrint.print_(self.screen, "Move Left: ")
            w += self.print_key_layout(3)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
            w = self.textPrint.print_(self.screen, "Move Right: ")
            w += self.print_key_layout(4)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
            w = self.textPrint.print_(self.screen, "Jump: ")
            w += self.print_key_layout(5)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
        if (self.use_mouse_to_aim_and_fire or self.use_hat_to_aim > -1):
            self.textPrint.println_(self.screen, "Aim in x direction: -")
            self.textPrint.println_(self.screen, "Aim in -x direction: -")
            self.textPrint.println_(self.screen, "Aim in y direction: -")
            self.textPrint.println_(self.screen, "Aim in -y direction: -")
        else:
            w = self.textPrint.print_(self.screen, "Aim in x direction: ")
            w += self.print_key_layout(6)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
            w = self.textPrint.print_(self.screen, "Aim in -x direction: ")
            w += self.print_key_layout(7)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
            w = self.textPrint.print_(self.screen, "Aim in y direction: ")
            w += self.print_key_layout(8)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
            w = self.textPrint.print_(self.screen, "Aim in -y direction: ")
            w += self.print_key_layout(9)
            self.textPrint.carriage_return(w)
            self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Use this Layout?")
        w += self.print_key_layout(10)
        pygame.display.flip()

    def print_key_layout(self, action_index):
        """Shows action to key mapping and which action to map as next.
        """
        w = 0
        if action_index == 0:
            w += self.textPrint.print_(self.screen, "{} (press a mouse button to toggle)".format(self.use_mouse_to_aim_and_fire))
        elif action_index == 1:
            w += self.textPrint.print_(self.screen, "{} (press a hat to toggle)".format(self.use_hat_to_aim))
        elif action_index == 2:
            w += self.textPrint.print_(self.screen, "{} (press a hat to toggle)".format(self.use_hat_to_move))
        if (action_index-2) in self.actions_map: #it is with offset
            i_index = action_index-2
            type = self.actions_map[i_index].type
            if pygame.JOYBUTTONDOWN == type:
                w += self.textPrint.print_(self.screen, "Button: {}, Joystick: {}".format(self.actions_map[i_index].button,
                                            self.actions_map[i_index].joy))
            elif pygame.JOYAXISMOTION == type:
                w += self.textPrint.print_(self.screen, "Axis: {}, Joystick: {}".format(self.actions_map[i_index].axis,
                                            self.actions_map[i_index].joy))
            elif pygame.KEYDOWN == type:
                w += self.textPrint.print_(self.screen, "Button: {}".format(pygame.key.name(self.actions_map[i_index].key)))
        if self.current_ui_point == action_index: #Current point to set
            if action_index == 10:
                w += self.textPrint.print_(self.screen, "   press enter to start   <----")
            else:
                w += self.textPrint.print_(self.screen, "  <----")
        return w
        