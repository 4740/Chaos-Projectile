"""
.. module:: controller
    :platform: Unix, Windows
    :synopsis: Generates events according input of various controllers connected to the game.
"""
#Protected keys: enter, escape
#

import pygame
import events
from pygame.constants import JOYBUTTONUP


BLACK    = (   0,   0,   0)
WHITE    = ( 255, 255, 255)

class Actions:
    MOVE_LEFT = 1
    MOVE_RIGHT = 2
    JUMP = 3
    AIM_X = 4
    AIM_MINUS_X = 5
    AIM_Y = 6
    AIM_MINUS_Y = 7

# This is a simple class that will help us print to the screen
class TextPrint:
    def __init__(self):
        self.reset()
        self.font = pygame.font.Font(None, 30)

    def print_(self, screen, textString):
        textBitmap = self.font.render(textString, True, BLACK)
        screen.blit(textBitmap, [self.x, self.y])
        width, height = self.font.size(textString);
        self.x += width
        return width

    def println_(self, screen, textString):
        self.print_(screen, textString)
        width, height = self.font.size(textString);
        self.x -= width
        self.line_break()
        return width

    def carriage_return(self, width):
        self.x -= width

    def line_break(self):
        self.y += self.line_height

    def reset(self):
        self.x = 10
        self.y = 10
        self.line_height = 30
        
    def indent(self):
        self.x += 10

    def unindent(self):
        self.x -= 10

class Input:
    """joystick_index = nr. of joystick_index, -1 no joystick_index
    """
    def __init__(self, input_type, key_index, joystick_index, value):
        self.type = input_type
        self.key_index = key_index
        self.joystick_index = joystick_index
        self.value = value
        #self.current_value = 0

    def is_a_key(self):
        return (self.type == pygame.KEYDOWN or self.type == pygame.KEYUP)

    def is_a_joystickbutton(self):
        return (self.type == pygame.JOYBUTTONDOWN or self.type == pygame.JOYBUTTONUP)
    
    def is_a_joystickaxis(self):
        return self.type == pygame.JOYAXISMOTION

    def equal(self, other_input):
        #Keyboard key:
        #KEYDOWN == KEYUP, same key_index --> same key toggled
        if self.is_a_key() and other_input.is_a_key():
            return (self.key_index == other_input.key_index)
        #Joystick button:
        #Similar to keyboard button, but one must check if the
        #toggled button is on the same joystick
        if self.is_a_joystickbutton() and other_input.is_a_joystickbutton():
            return (self.key_index == other_input.key_index and
                    self.joystick_index == other_input.joystick_index)
        #Joystick axis (or axis direction):
        #distinguish between axis which is slanted left vs right
        #(or top vs. bottom)
        #Example: when self and other_input are both slanted left,
        #have similar axis index and joystick index, then the same
        #axis was moved
        if self.is_a_joystickaxis() and other_input.is_a_joystickaxis():
            offset = 0.04 #Filter to small values
            return (((self.value > offset and other_input.value > offset) or
                    (self.value < offset and other_input.value < offset)) and
                    self.key_index == other_input.key_index and
                    self.joystick_index == other_input.joystick_index)
        else:
            return (self.type == other_input.type and
                    self.key_index == other_input.key_index and
                    self.joystick_index == other_input.joystick_index and
                    self.value == other_input.value)

class InputController:
    """InputController manages connected controllers and takes events generated by them sending other events to the game.

    :Attributes:
        - *event_manager* (events.EventManager): event manager
        - *joystick* (pygame.joystick.Joystick): game pad
    """

    def __init__(self, screen, event_manager):
        #Register InputController, so it can handle events
        self.event_manager = event_manager
        self.event_manager.register_listener(self)
        #Needed for custom control screen render
        self.screen = screen
        self.textPrint = TextPrint()
        #To store controlls
        self.actions_map = {}
        self.init_counter = 1
        self.custom_keys_ready = False
        self.use_mouse_to_aim_and_fire = True
        self.controls_ready = False
        #Register game pads that are connected
        pygame.joystick.init()
        self.joystick = None
        self.joystick_count = pygame.joystick.get_count()
        for i in range(self.joystick_count):
            joystick = pygame.joystick.Joystick(i)
            joystick.init()

    def init_right_joystick(self):
        """If there are more then one joysticks connected.
        Recognize the right one.
        """
        for i in range(self.joystick_count):
            joystick = pygame.joystick.Joystick(i)
            if joystick.get_button(7):
                self.joystick = joystick
                self.joystick.init()
                return

    def notify(self, event):
        if isinstance(event, events.TickEvent):
            for event in pygame.event.get():
                #Common events
                if event.type == pygame.VIDEORESIZE:
                    resize_ev = events.ResizeWindowEvent(event.w, event.h)
                    self.event_manager.post(resize_ev)
                if event.type == pygame.QUIT:
                    quit_ev = events.QuitEvent()
                    self.event_manager.post(quit_ev)
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        quit_ev = events.QuitEvent()
                        self.event_manager.post(quit_ev)
                    if event.key == pygame.K_RETURN: #the enter key
                            self.event_manager.post(events.TogglePauseEvent())
                            #self.custom_keys_ready = True
                            self.controls_ready = True
                            #if not self.custom_keys_ready:
                            #self.init_default_control()
                            

                #Default keyboard-mouse controls
                '''
                if not self.custom_keys_ready:
                    #Handle events generated by keyboard
                    if event.type == pygame.KEYDOWN:
                        key_ev = events.KeyPressed(event.key)
                        self.event_manager.post(key_ev)
                    if event.type == pygame.KEYUP:
                        key_ev = events.KeyReleased(event.key)
                        self.event_manager.post(key_ev)
                    #Handle events generated by mouse
                    if event.type == pygame.MOUSEMOTION:
                        direction_X, direction_Y = pygame.mouse.get_pos()
                        mouse_ev = events.MouseMoved(direction_X, 
                                                     direction_Y)
                        self.event_manager.post(mouse_ev)
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        attack_request_ev = events.MouseButtonDown()
                        self.event_manager.post(attack_request_ev)
                '''

                if self.controls_ready:
                    inpt = self.determine_input(event)
                    if (inpt and self.key_used(inpt)):
                        action = self.determine_action(inpt)
                        if action:
                            input_event = events.SentInputAction(action, inpt)
                            self.event_manager.post(input_event)

                #If custom keys are not initialized
                if not self.controls_ready:
                    if not self.custom_keys_ready and event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_BACKSPACE:
                            self.dec_input_counter()
                    #for the TickEvent
                    if not self.custom_keys_ready:
                        self.draw()
                        inpt = self.determine_input(event)
                        if (inpt and not self.key_used(inpt)):
                            self.save_key(inpt)
                '''
                    if self.joystick.get_button(7) and self.joystick.get_button(6):
                        #
                        #XBox button(6) = back button(7) = start
                        #
                        #K-key resets the game
                        key_ev = events.KeyPressed(pygame.K_k)
                        self.event_manager.post(key_ev)
                if event.type == pygame.JOYAXISMOTION:
                    horiz_axis_pos, vert_axis_pos = self.get_axis_pos()
                    #Game pad events will be sent every tick
                    #Get second axis values and send this as an event
                    axis_ev = events.AxisMoved(horiz_axis_pos,
                                               vert_axis_pos)
                    self.event_manager.post(axis_ev)
                if event.type == pygame.JOYHATMOTION:
                    if self.joystick.get_hat(0):
                        #Get hat values and send this as an event
                        hat_x, hat_y = self.joystick.get_hat(0)
                        hat_ev = events.HatMoved(hat_x, hat_y)
                        self.event_manager.post(hat_ev)
                '''
            '''
            if self.joystick and self.joystick.get_numaxes() > 3:
                horiz_axis_pos, vert_axis_pos = self.get_axis_pos()
                offset_value_for_attack_req = 0.5
                if abs(horiz_axis_pos) > offset_value_for_attack_req or abs(vert_axis_pos) > offset_value_for_attack_req:
                    attack_request_ev = events.MouseButtonDown()
                    self.event_manager.post(attack_request_ev)
            '''

    def get_axis_pos(self):
        """Get Axis position. When no joystick connected, returns (0,0)
        """
        '''
        XBox game pad 2. axis: X 3, Y 4
        Sony game pad 2. axis: X 3, Y 2
        '''
        horiz_axis_pos = 0
        vert_axis_pos = 0
        if self.joystick and self.joystick.get_numaxes() > 3:
            horiz_axis_pos = self.joystick.get_axis(2)
            vert_axis_pos = self.joystick.get_axis(3)
        return(horiz_axis_pos, vert_axis_pos)

    def store_input_value(self, action, event):
        if action in self.actions_map:
            new_value = 0
            joystick_index = self.actions_map[action].joystick_index
            button_index = self.actions_map[action].key_index
            if event.type == pygame.JOYBUTTONDOWN:
                active_joystick = pygame.joystick.Joystick(joystick_index)
                btn_state = active_joystick.get_button(button_index)
            self.actions_map[action].current_value = new_value

    def init_default_control(self):
        moveLeft = Input(pygame.KEYDOWN, pygame.K_a, -1, 1)
        moveRight = Input(pygame.KEYDOWN, pygame.K_d, -1, 1)
        jump = Input(pygame.KEYDOWN, pygame.K_w, -1, 1)
        #self.use_mouse_to_aim_and_fire = True
        self.actions_map[1] = moveLeft
        self.actions_map[2] = moveRight
        self.actions_map[3] = jump
        
        self.actions_map[4] = Input(pygame.KEYDOWN, pygame.K_RIGHT, -1, 1)
        self.actions_map[5] = Input(pygame.KEYDOWN, pygame.K_LEFT, -1, 1)
        self.actions_map[6] = Input(pygame.KEYDOWN, pygame.K_UP, -1, 1)
        self.actions_map[7] = Input(pygame.KEYDOWN, pygame.K_DOWN, -1, 1)
        
        self.controls_ready = True
            
    def determine_action(self, inpt):
        for action, control in self.actions_map.iteritems():
            if control.equal(inpt):
                return action
        return None

    def determine_input(self, event):
        """Constructs Input instance
        """
        inpt = None
        if event.type == pygame.JOYBUTTONDOWN or event.type == pygame.JOYBUTTONUP:
            #determine on which joystick the button in down
            for joystick_index in range(self.joystick_count):
                active_joystick = pygame.joystick.Joystick(joystick_index)
                #determine which button is pressed
                for button_index in range(active_joystick.get_numbuttons()):
                    if button_index == event.button:
                        inpt = Input(event.type, button_index, joystick_index, 1)
        if event.type == pygame.JOYHATMOTION:
            #determine on which joystick the hat is pressed
            for joystick_index in range(self.joystick_count):
                active_joystick = pygame.joystick.Joystick(joystick_index)
                #determine which hat is pressed
                for hat_index in range(active_joystick.get_numhats()):
                    if active_joystick.get_hat(hat_index):
                        inpt = Input(pygame.JOYHATMOTION, hat_index, joystick_index, 1)
        if event.type == pygame.JOYAXISMOTION:
            if event.joy in range(self.joystick_count):
                active_joystick = pygame.joystick.Joystick(event.joy)
                if event.axis in range(active_joystick.get_numaxes()):
                    inpt = Input(pygame.JOYAXISMOTION, event.axis, event.joy, event.value)
            '''
            #determine on which joystick the axis is moved
            for joystick_index in range(self.joystick_count):
                active_joystick = pygame.joystick.Joystick(joystick_index)
                #determine which axis is moved
                for axis_index in range(active_joystick.get_numaxes()):
                    if active_joystick.get_axis(axis_index):
                        axis_pos = active_joystick.get_axis(axis_index)
                        inpt = Input(pygame.JOYAXISMOTION, axis_index, joystick_index, axis_pos)
                        break
            '''
        if event.type == pygame.KEYDOWN or event.type == pygame.KEYUP:
            #A key on the keyboard is pressed
            inpt = Input(event.type, event.key, -1, 0)
        return inpt

    def save_key(self, inpt):
        """Save input to an action. Action index stored in inc_init_counter
        """
        if not(inpt.key_index == pygame.K_BACKSPACE or
                inpt.key_index == pygame.K_ESCAPE or
                inpt.key_index == pygame.K_RETURN or
                inpt.type == pygame.KEYUP or inpt.type == pygame.JOYBUTTONUP or
                (inpt.type == pygame.JOYAXISMOTION and abs(inpt.value)<0.5)):
            self.actions_map[self.init_counter] = inpt
            self.inc_init_counter()

    def key_used(self, control):
        """Is control already mapped to action.
        """
        for value in self.actions_map.itervalues():
            if value.equal(control):
                return True
        return False

    def inc_init_counter(self):
        """Helper for actions counter.
        """
        if self.init_counter >= 7:
            self.init_counter = 1
        else:
            self.init_counter += 1

    def dec_input_counter(self):
        """Helper for actions counter.
        """
        if self.init_counter > 1:
            self.init_counter -= 1
        else:
            self.init_counter = 7

    def draw(self):
        """Used for custom controlls initialisation screen
        
        :param dt: CPU tick
        :type dt: int
        """
        self.screen.fill(WHITE)
        self.textPrint.reset()
        self.textPrint.println_(self.screen, "Custom control")
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Move Left: ")
        w += self.print_key_layout(1)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Move Right: ")
        w += self.print_key_layout(2)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Jump: ")
        w += self.print_key_layout(3)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Aim in x direction: ")
        w += self.print_key_layout(4)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Aim in -x direction: ")
        w += self.print_key_layout(5)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Aim in y direction: ")
        w += self.print_key_layout(6)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()
        w = self.textPrint.print_(self.screen, "Aim in -y direction: ")
        w += self.print_key_layout(7)
        self.textPrint.carriage_return(w)
        self.textPrint.line_break()

        pygame.display.flip()

    def print_key_layout(self, action_index):
        """Shows action to key mapping and which action to map as next.
        """
        w = 0
        if action_index in self.actions_map:
            if (pygame.JOYBUTTONDOWN == self.actions_map[action_index].type or
                pygame.KEYDOWN == self.actions_map[action_index].type):
                w += self.textPrint.print_(self.screen, "Button: ")
            elif pygame.JOYHATMOTION == self.actions_map[action_index].type:
                w += self.textPrint.print_(self.screen, "Hat: ")
            elif pygame.JOYAXISMOTION == self.actions_map[action_index].type:
                w += self.textPrint.print_(self.screen, "Axis: ")
            if pygame.KEYDOWN == self.actions_map[action_index].type:
                w += self.textPrint.print_(self.screen, pygame.key.name(self.actions_map[action_index].key_index))
            else:
                w += self.textPrint.print_(self.screen,
                                           " index: {}, Joystick index: {}".format(self.actions_map[action_index].key_index,
                                            self.actions_map[action_index].joystick_index))
        if self.init_counter == action_index: #Current action to set
            w += self.textPrint.print_(self.screen, "  <----")
        return w
        